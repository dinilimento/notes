
Spring + JPA cursus Infosupport
-------------------------------

Java 1995, meegelift op Internethype via Applets + dynamische code

Java Standard edition draait in JVM
JVM 
- vertaalt classfiles naar bytecode en naar platform
- garbage collection
- security manager
- 

Microsoft .NET -> java van microsoft

Java 2000, enterprise 
-> Gaat niet meer alleen uit van JVM, maar geeft al een aantal voorzieningen mee voor uitdagingen voor elk bedrijf
-> standardiseren van veelvoorkomende handlingen als bijv. het mappen van URL's op methodes
(URLs mappen naar methodes via ServletSpec)

JDBC: java database connectivity
-> moet je alsnog sql schrijven in je java applicatie
JPA: java persistence api
-> vanuit objecten naar DB toe

JAAS: java authentication and authorisation specification
JavaMail: mail server aansluiten
JMS: Java messaging specificatie

JEE app is eigenlijk geen app, maar een toevoeging aan een bestaande app.
JEE beschrijft ook hoe je app moet communiceren met de bestaande componenten

Java Application wordt "Application Server" genoemd
IBM brengt hiervan Websphere uit
Oracle Weblogic
Tommy? Tomcat
Application server wordt ook wel container genoemd

Sun brengt een paar nieuwe goodies uit die "te geniaal" waren waardoor het gebruik niet goed ging en alles kapot ging

Rod Johnson wordt architect bij Sun. Schrijft het boek "Expert One-on-One J2EE Design and Development" 
-> hoe bouw je met JEE een goede applicatie. Geeft aan: gebruik deze dingen absoluut niet en deze dingen wel
Later vormen de dingen die wel goed werken de basis voor het Spring framework

********************
Spring Framework 1.0
********************
- Op basis van POJO's
- Dependency injection (framework)
- AOP: Aspect oriented programming

Deze drie vormen samen de Spring Core Module

Gebruiken design patterns om de goede dingen uit JEE te vergemakkelijken
Belangrijke is het Template Pattern

Hierdoor wordt veel werk uit handen genomen, daardoor wordt Spring groots ten nadele van alle dure oplossingen

Applicatie Server = container
Container bevat:
- Webcontainer
- EJB container

Spring container vervangt de EJB container

Webcontainer: Tomcat, Jetty, Undertow. JBoss is soort spring maar dan nog niet zo oud


De opkomst van de relationele database:
Abstractie van al het gezeik met files zodat je alleen nog commando hoeft te geven en het wordt opgeslagen
Later ook de komst van de transactie waarmee allerlei safeguards ingebouwd worden

Alle RDBS: API waartegen je kan aanpraten
Client side API kan je aanspreken en die API zoekt dan de overeenkomstige server side API en geeft door`

Praten tegen RDBS die in C is geschreven? Hoe moet dat vanuit Java?
JVM is natuurlijk ook in C geschreven...
JNI: Java Native Interface
Hiermee kan je java code koppelen aan een variant in C code.
JNI wordt ook uitbundig gebruik in de JRE

Kan via JNI alle methodes mappen op de C methodes en dan via Client API naar RDB.
Komt er een nieuwe DB zoals bijv. DB2? Alles opnieuw maken....
Dat is niet handig dus: JDBC API ertussen
Via JDBC: standaard gedragingen beschrijven en daarvoor specificeren wat er moet gebeuren op DB
Bestaat uit Interfaces:
- Connection
- Statement
- ResultSet
En maar één klasse met gedrag:
- Driver manager
    -> Register methode. Als er een DB aan wordt gekoppeld bewaard de manager de connecties etc. 
       zodat je aan de Driver manager referenties kan opvragen


Nu kan Oracle op basis van de JDBC hun eigen JNI implementatie schrijven
Dit heet de JDBC driver voor (oracle/db2/andere vendor of implementatie)

Mavenproject:
- Group ID: wereldwijd uniek zijn
- Artefact ID: binnen bedrijf uniek zijn

JDBC: checked exceptions -> worden door compiler opgevangen

ORM frameworks: object relational mapping framework
Bedoelt om af te komen van de harde koppeling via JDBC tussen objecten en DB model

Bijv: Hibernate = ORM framework
Dit is een high-level abstractie die leunt op JDBC

Je hebt hiernaast bijv. ook EclipseLink (vanuit Oracle, maar gedoneerd aan open source community, doet het goed op OracleDB) of OpenJPA (goed op IBM, DB2)

Als ontwikkelaar wil je daarbovenop natuurlijk nog een mogelijkheid om alles op zelfde manier te regelen:
JPA!
Tussen JPA en java app zit nog een entity manager die persist() kan doen en dan zou alles netjes in DB moeten komen

Implementeren:
- mvn dependency (hibernate heeft JPA aan boord)
- config maken (main of test /resources) -> kan andere settings gebruiken voor main of test
- google naar persistence.xml 
- object annoteren met @Entity: wordt mapping gemaakt tussen klasse en DB-tabel
- @Id geeft aan welk attribuut het object uniek maakt
- Transaction-type: resource JTA
- nu nog even zelf transactie starten en committen

IntelliJ heeft via ctrl + shift + a een optie Data Sources... en daarin kan je configureren waar je DB is zodat je via IntelliJ
geen fouten meer krijgt op db naam

Persistence.createEntityMangerFactory() doet erg veel werk, zoals:
Persistence Unit inlezen
Inladen klassen
Connectie maken naar DB
Code voor Inserts/Deletes/Updates genereren
Screenen van tabellen en eventueel aanmaken/updaten
Dus niet te vaak doen, want dure transactie!!!

Persist commando zet een opdracht op een lijstje (persistence context)
Flush voert commando's uit, wil je normaal eigenlijk niet doen kan als onderdeel van de commit.
Flush zet wel locks, die blijven staan tot de commit dus nooit flushen, maar gewoon in commit.
Commit maakt alle opdrachten echt definitief, de DB laat dit dan aan de Clients zien.

Alle Entity's die op het lijstje staan als referenties worden "Managed" genoemd

Voor JPA is de persistence context de waarheid. Hij leest daar altijd doorheen.
Dus bij een find van object wat in persistence context staat zal die niet naar de DB gaan.
Hiervoor kan je evt. de clear() methode gebruiken om de cache te legen.

Je zou dus in twee runtimes lekker bezig kunnen zijn en dan in je pers. context alles gecached hebben waardoor je de waarheid (db) niet meer kent.
Hiervoor kan je de klassen verrijken met: 

@Version
@Getter(value=AccessLevel.NONE) -> zorgen dat anderen hier af blijven, mag alleen voor DB gebruikt worden
@Setter(value=AccessLevel.NONE) -> zorgen dat anderen hier af blijven, mag alleen voor DB gebruikt worden
private long rowversion;

Optimistic Concurrency Control:
Niet locken vooraf/bij select, maar bij mutaties kijken of je nog de juiste versie hebt

Zit er misschien auto-enabled row versioning in?
Alternatief: @Entity superklasse met rowversioning



